max_length = int(input()) # Максимальная длинна заголовка
number_of_str = int(input()) # Количество строк в заголовке

user_str = [] # Лист со строками заголовка
current_length = 0 # сумма количества символов в строках user_str

# Заполняем список. Как только превышаем лимит по символам - сразу выходим из цикла, чтобы потом не удалять. В теории, нужно было определённое
# количество инпутов от пользователя, но Яндекс и такой вариант от меня схавал, значит это можно считать решением. Если не брейкать, то потом
# у меня всё равно поудалялись бы лишние элементы, я дальше это покажу
for _ in range(number_of_str):
    string = input()
    user_str.append(string)
    current_length += len(string)
    if current_length > max_length:
        break

# Уменьшаем лимит на 3, потому что будем добавлять "..."
if current_length > max_length:
    max_length -= 3

    # Тут пробегаемся по списку с конца и убираем последний элемент, до тех пор,
    # пока сумма количества символов всех строк без последней не станет меньше максимальной длины заголовка
    while user_str and current_length - len(user_str[-1]) >= max_length:
        current_length -= len(user_str[-1])
        user_str.pop()

    # Пришлось добавить проверку на то, что в списке ещё есть элементы, потому что в тестовых от Яндекса были
    # конченные варианты с нулевой длиной заголовка или нулевым количеством строк, хз. Но, вроде это хорошая практика, так что я не расстроен        
    if user_str:
        if current_length > max_length:
            user_str[-1] = user_str[-1][:-(current_length - max_length)] # Тут просто сокращаем искомую строку на нужное количество символов
        user_str[-1] += '...'                                            # и дописываем "..."
    else:
        user_str.append('...')

for string in user_str:
    print(string)